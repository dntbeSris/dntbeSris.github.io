[{"title":"Nacos源码分析之naming","url":"/2018/12/02/spring-cloud-alibaba_1/","content":"\n# Nacos源码分析之naming\n\n**nacos的naming服务采用分布式一致性算法-raft，来实现包括集群leader选举，数据和事物同步等功能。所以这一节也主要是分析raft在nacos-naming中的代码实现，以及个人的见解。**\n\n\n\n### 项目初始化\n\n整个nacos都是采用spring-boot作为基础框架，naming服务也不例外。整个raft算法的核心类为RaftCore类，其启动类为RunningConfig。RunningConfig实现了Spring-boot的ApplicationListner<WebServerInitializedEvent>,即在整个web项目初始化后即执行RunningConfig，在启动函数onApplicationEvent中启动RaftCore的初始化方法init(),代码如下。\n\n```\n@Component\npublic class RunningConfig implements ApplicationListener<WebServerInitializedEvent> {\n\n    private static int serverPort;\n\n    private static String contextPath;\n\n    @Autowired\n    private ServletContext servletContext;\n\n    //启动函数，执行了RaftCore.init()方法。\n    @SuppressFBWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    @Override\n    public void onApplicationEvent(WebServerInitializedEvent event) {\n\n        Loggers.SRV_LOG.info(\"[SERVER-INIT] got port:\" + event.getWebServer().getPort());\n        Loggers.SRV_LOG.info(\"[SERVER-INIT] got path:\" + servletContext.getContextPath());\n\n        serverPort = event.getWebServer().getPort();\n        contextPath = servletContext.getContextPath();\n\n        try {\n            RaftCore.init();\n        } catch (Exception e) {\n            Loggers.RAFT.error(\"VIPSRV-RAFT\", \"failed to initialize raft sub system\", e);\n        }\n    }\n\n    public static int getServerPort() {\n        return serverPort;\n    }\n\n    public static String getContextPath() {\n        return contextPath;\n    }\n}\n```\n\n接下来就是算法的核心类RaftCore了。这个类主要做了初始化工作，以及启动了三个scheduler分别定时执行MasterElection(Master选举）选举线程，HeartBeat(心跳连接)线程和AddressServerUpdater(集群服务添加和删除)线程。其中还有","tags":["Java,Nacos,Spring-cluod-alibaba,微服务"]},{"title":"Spring-cloud-alibaba初体验之Nacos","url":"/2018/11/21/spring-cloud-alibaba_0/","content":"\n*此系列不涉及实现原理，执行流程等稍微底层的知识，旨在使用Spring-clouod-alibaba各组建快速搭建一套分布式微服务框架。个人以为微服务的基础组件是服务的注册以及配置中心。而阿里摒弃了繁重的Zookeeper，采用新开源的Nacos作为服务注册发现中心，Nacos同样提供了配置中心的功能。有人认为注册中心与配置中心不应该耦合在一起，但是conusol不就是这么做的吗？当然在社区交流中有提到在可将注册中心与配置中分别单独启动，后续怎么样暂无法预期。在利用spring-cloud-alibaba的各个组建搭建一套微服务之前，还是先重点分析Nacos。*\n\n___\n## 什么是Nacos?\n\nNacos是一个应用的动态服务发现、配置管理和服务管理平台。Nacos采用raft分布式一致性算法，关于为什么摒弃zookeeper，raft与zab算法的区别与优劣可以另外阅读资料或者看我之前的博客作简单了解。关于Nacos的具体介绍可阅读官方文档：https://nacos.io。\n\n## 如何使用Nacos？\n\n1. 首先[github]()下载nacos，解压进入nacos根目录，可以看到以下几个文件夹。\n```\n\n unzip nacos-server-$version.zip 或者 tar -xvf nacos-server-$version.tar.gz\n cd nacos && ls\n bin  conf  data  LICENSE  logs  NOTICE  target\n```\n2. 集群启动配置，简单介绍一下这几个文件夹的作用\n\n* **bin**：启动nacos的shell或在cmd脚本，可以自定义一些jvm启动参数，如果jdk版本过新可能需要修改一些jvm参数，否则可能会报错。比如我的机器的ubuntu，jdk版本是openjdk10，就启动报错，修改一些jvm参数后成功启动。\n*  **conf**：集群节点以及持久化方式配置。看一下conf下分别有哪些文件\n  ```\n  zjx@zjx-X550JK:~/app/nacos$ ls conf/\napplication.properties          cluster.conf.example  nacos-mysql.sql\napplication.properties.example  nacos-logback.xml     schema.sql\n    \n  ```\n  如果需要部署集群，则配置cluser.conf，将集群ip列表配置上即可。当然如果不做配置，默认以standalone即单机模式运行。要配置持久化方式为mysql的话，需要执行schema.sql，创建相应的数据库以及表结构。 然后在application.properties中配置mysq连接参数即可，如果不做配置，持久化方式莫认为derby。最后是loback日志配置。\n* **target**:nacos应用程序的可执行jar包。\n* **logs**： 日志文件\n\n3. 在进行启动配置之后，就可以启动nacos了，linux下执行。\n\n```\nsh startup.sh 或者 sh startup.sh -m standalone\n```\n**-m standalone**即以单机模式运行。启动成功的界面如下。\n\n```\n                                                        \n         ,--.                                           \n       ,--.'|                                           \n   ,--,:  : |                                           Version: 0.4.0\n,`--.'`|  ' :                       ,---.               Port: 8848\n|   :  :  | |                      '   ,'\\   .--.--.    Console: http://localhost:8848/nacos/index.html\n:   |   \\ | :  ,--.--.     ,---.  /   /   | /  /    '   \n|   : '  '; | /       \\   /     \\.   ; ,. :|  :  /`./   \n'   ' ;.    ;.--.  .-. | /    / ''   | |: :|  :  ;_         https://nacos.io\n|   | | \\   | \\__\\/: . ..    ' / '   | .; : \\  \\    `.  \n'   : |  ; .' ,\" .--.; |'   ; :__|   :    |  `----.   \\ \n|   | '`--'  /  /  ,.  |'   | '.'|\\   \\  /  /  /`--'  / \n'   : |     ;  :   .'   \\   :    : `----'  '--'.     /  \n;   |.'     |  ,     .-./\\   \\  /            `--'---'   \n'---'        `--`---'     `----'                        \n\n```\n4. 最后浏览器打开[http://localhost:8848/nacos/index.htmlnacos主页](http://localhost:8848/nacos/index.html)即可看到nacos控制界面如下图：\n\n![nacos主页](/images/nacos.png)\n\n\n## 总结\n\nnacos的介绍和使用基本就是上面的内容，了解更多细节可以查阅[官网](https://nacos.io)。接下来会试着从源码角度解读nacos。","tags":["Java,Spring-cluod,微服务"]},{"title":"中间件之MQ-对比篇","url":"/2018/11/07/mq-1/","tags":["中间件"]},{"title":"记一次性能压测","url":"/2018/11/04/stressTesting/","content":"## 记一次性能压测 \n\n*(文中的所有图片数据均非真实数据，仅供示意使用。)*\n___\n\n### 服务环境\n\n1. k8s集群\n2. Node与Java后台服务\n3. 服务对外是通过http通信\n4. 服务之间通信也是http，但是是k8s集群内的通信\n\n### 压测工具\n\n1. **wrk**，一款http压测工具\n2. top查看cpu利用率\n3. jvisualvm，jconsole，jstat等JVM监测工具\n\n> 这里对于以上的工具使用不多做介绍，主要介绍压测的一些步骤和思路。但是，这里有个问题jvisualvm，jconsole无法连接容器内的Java服务，只能通过jstat查看JVM内存和垃圾回收情况。\n\n\n### 首先就是用wrk对服务进行压测,wrk是C语言编写，需要配合简单的lua脚本使用。至于wrk好不好用，怎么样看个10分钟教程就好了。\n\n```\nwrk -t 8 -c 8 -d 60s --latency  \"http://www.xxx.com\"\n```\n\n我们使用8个线程，8个连接数对**http://www.xxx.com**服务进行60s的压测，首先我们到物理机查看cpu的利用率。\n\n![cpu](/images/cpu.png)\n\n然后持续加大压力，即增加wrk的线程数和连接数，知道cpu的使用率到600%-1000%，我们才认为压力上来了。然后查看wrk的压测结果\n\n![wrk](/images/wrk.png)\n\nNode服务对我们来说并发并不高，我们不太关系性能，只是简单的通过扩展K8S的pod数就好了。但是Java的并发是很高的，我们希望单机下能够要达到1w+的qps，并且90%的延迟是希望能控制在5ms以内的。那压测结果的qps还是能满足我们的要求，但是延迟显然是不能满足我们的要求的。所以就需要服务的耗时花在哪？\n\n### 通过jvisualvm，jconsole，jstat等监测JVM的使用情况。\n\n**从简到易，首先使用jstat查看内存和垃圾回收情况。**\n\n![jstat](/images/jstat.png)\n\n我们发现了又好几次的FGC，这是不能接受的。于是将JVM内存从4G扩到6G，老年代4G，新时代2G。之后发现FGC降下来了，但是还是有2次FGC，是在服务启动阶段进行的，判定为是web容器和spring框架启动产生的，所以不予理会。但是在耗时上耗时不能满足要求。\n\n**然后使用jvisualvm连接Java服务。**\n\n![jvisualvm](/images/jvisualvm.png)\n\n查看内存和垃圾回收情况都很正常，但是查看CPU耗时具体在那个方法上。定位到方法，发现这个方法中用了parallelStream()并行计算，并且里面有锁，便怀疑是锁竞争导致的耗时，想办法消除临界区资源，把可变状态都控制在单个线程内，即进行锁消除。\n\n> ## 最后在进行压测，发现qps和延迟都能够满足要求。 \n\n","tags":["压测"]},{"title":"中间件之MQ-基础篇","url":"/2018/10/31/mq-0/","tags":["中间件"]},{"title":"中间件之RPC-对比篇","url":"/2018/10/22/rpc-1/","tags":["中间件"]},{"title":"中间件之RPC-基础篇","url":"/2018/10/10/rpc-0/","tags":["中间件"]},{"title":"AQS浅析(三)","url":"/2018/10/03/AQS-2/","tags":["Java"]},{"title":"AQS浅析(二)","url":"/2018/09/29/AQS-1/","tags":["Java"]},{"title":"AQS浅析(一)","url":"/2018/09/21/AQS-0/","tags":["Java"]},{"title":"分布式一致性-Raft","url":"/2018/09/11/distributed_consensus-3/","tags":["分布式"]},{"title":"分布式一致性-ZAB","url":"/2018/09/01/distributed_consensus-2/","tags":["分布式"]},{"title":"分布式一致性-Paxos","url":"/2018/08/23/distributed_consensus-1/","tags":["分布式"]},{"title":"分布式一致性-基础协议","url":"/2018/08/18/distributed_consensus-0/","tags":["分布式"]},{"title":"Netty简介","url":"/2018/08/11/netty/","content":"\n### Netty核心组件\n\n-  Channel：封装了NIO的Channel,相当于数据载体，提供打开，关闭连接，读写数据等基本I/O操作。\n- EventLoopGroup：继承自ScheduleServiceExecutor,相当与线程池，管理EventLoop,每个EventLoop对应一个线程\n- EventLoop：一个Channel生命周期内注册一个EventLoop，一个EventLoop分配给一个或多个Channel,I/O事件处理器。\n- ChannelFuture:继承自juc的Future，提供异步I/O操作，addListener()方法注册一个ChannelFutureListner。\n- ChannelHandler:充当所有出入站数据的容器，处理应用程序逻辑。\n- ChannelPipeline:管道架构，当Channel被创建时，自动分配一个ChannelPipeline，然后经过ChannelPipeline中的ChannelHandler链对数据进行处理，ChannelHandler被安装注册到ChannelPipeline的过程如下：\n1. 实现ChannelInitailizer接口\n2. 注册到ServerBootstrap/Bootstrap\n3. 调用ChannelInitializer.initChannel方法\n4. ChannelInitializer在ChannelPipeline中安装一组自定义的ChannelHandler\n5. ChannelInitializer 将它自己从 ChannelPipeline 中移除\n> ServerBootstrap需要两个EventLoopGroup,Bootstrap需要一个EventloopGroup,\n这是因为服务端要处理两种类型的Channel,其中一个EventLoopGroup负责处理ServerChannel，用来监听链接；另一个负责处理Channel，用来处理客户端连接事件。\n\n\n### ChannelHandler\n\n#### 两个重要的ChannelHandler子接口：\n- ChannelInboundHandler :处理入站数据以及各种状态变化。\n- ChannelOutboundHandler ：处理出站数据并且可拦截所有操作。\n\nChannelHandler相关类图如下：\n![image]()\n\n\n### 资源管理\n **在调用**\n ```\n chnnelInboundHandler.channelRead();\n ```\n**或者**\n```\nchannelOutboundHandler.write();\n```\n**时，应正确使用引用计数来释放资源，否则容易造成内存泄露。在jvm启动参数添加如下值来开启Netty内存泄漏检测：**\n```\njava -Dio.netty.leakDetectionLevel=ADVANCED;\n```\n**Netty四个内存检测级别如下表:**\n\n级别 | 描述\n---|---\nDISABLED| 禁用泄漏检测。只有在详尽的测试之后才应设置为这个值\nSIMPLE| 使用 1%的默认采样率检测并报告任何发现的泄露。这是默认级别，适合绝大部分的情况\nADVANCED|使用默认的采样率，报告所发现的任何的泄露以及对应的消息被访问的位置\nPARANOID|类似于 ADVANCED，但是其将会对每次（对消息的）访问都进行采样。这对性能将会有很大的影响，应该只在调试阶段使用\n\n**看看Netty种ChannelInboundHandler和ChannelOutboundHandler的子类是如何处理入站和出站消息的。**\n- **ChannelInboundHandler子类SimpleChannelInboundHandler的channelRead()源码如下**\n\n```\npublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        boolean release = true;\n\n        try {\n            if(this.acceptInboundMessage(msg)) {\n                this.channelRead0(ctx, msg);\n            } else {\n                release = false;\n                ctx.fireChannelRead(msg);\n            }\n        } finally {\n            if(this.autoRelease && release) {\n                ReferenceCountUtil.release(msg);\n            }\n\n        }\n\n    }\n\n```\n> 需要注意上面的两个方法。一个是fireChannelRead()，其作用是将数据传给下一个ChannelHandler处理。而finnaly里面的ReferenceCountUtil就是利用引用计数来释放资源。\n\n- **ChannelOutboundHandler子类SslHandler的write()源码如下**\n```\npublic void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        if(!(msg instanceof ByteBuf)) {\n            UnsupportedMessageTypeException exception = new UnsupportedMessageTypeException(msg, new Class[]{ByteBuf.class});\n            ReferenceCountUtil.safeRelease(msg);\n            promise.setFailure(exception);\n        } else if(this.pendingUnencryptedWrites == null) {\n            ReferenceCountUtil.safeRelease(msg);\n            promise.setFailure(newPendingWritesNullException());\n        } else {\n            this.pendingUnencryptedWrites.add((ByteBuf)msg, promise);\n        }\n\n    }\n```\n\n> 引用计数释放资源不用多说了，重点关注promise.setFailure()方法，看源码可知ChannelPromise继承自ChannelFuture，其主要作用是通知ChannelFuture,并notify其中的ChannelFutureListener进行消息处理的通知。\n\n\n### ChnnelPipeline\n\n>ChannelPipeline是ChannelHandler处理链的容器。其只要核心API如下接口所示,主要是用来添加修改替换删除ChannelHandler。ChannelHandler链是一个链表结构，处理链严格按照ChannelHandler添加进ChannelPipeline的先后次序执行。\n\n```\npublic interface ChannelPipeline extends ChannelInboundInvoker, ChannelOutboundInvoker, Iterable<Entry<String, ChannelHandler>> {\n    ChannelPipeline addFirst(String var1, ChannelHandler var2);\n\n    ChannelPipeline addFirst(EventExecutorGroup var1, String var2, ChannelHandler var3);\n\n    ChannelPipeline addLast(String var1, ChannelHandler var2);\n\n    ChannelPipeline addLast(EventExecutorGroup var1, String var2, ChannelHandler var3);\n\n    ChannelPipeline addBefore(String var1, String var2, ChannelHandler var3);\n\n    ChannelPipeline addBefore(EventExecutorGroup var1, String var2, String var3, ChannelHandler var4);\n\n    ChannelPipeline addAfter(String var1, String var2, ChannelHandler var3);\n\n    ChannelPipeline addAfter(EventExecutorGroup var1, String var2, String var3, ChannelHandler var4);\n\n    ChannelPipeline addFirst(ChannelHandler... var1);\n\n    ChannelPipeline addFirst(EventExecutorGroup var1, ChannelHandler... var2);\n\n    ChannelPipeline addLast(ChannelHandler... var1);\n\n    ChannelPipeline addLast(EventExecutorGroup var1, ChannelHandler... var2);\n\n    ChannelPipeline remove(ChannelHandler var1);\n\n    ChannelHandler remove(String var1);\n\n    <T extends ChannelHandler> T remove(Class<T> var1);\n\n    ChannelHandler removeFirst();\n\n    ChannelHandler removeLast();\n\n    ChannelPipeline replace(ChannelHandler var1, String var2, ChannelHandler var3);\n\n    ChannelHandler replace(String var1, String var2, ChannelHandler var3);\n\n    <T extends ChannelHandler> T replace(Class<T> var1, String var2, ChannelHandler var3);\n\n    ChannelHandler first();\n\n    ChannelHandlerContext firstContext();\n\n    ChannelHandler last();\n\n    ChannelHandlerContext lastContext();\n\n    ChannelHandler get(String var1);\n\n    <T extends ChannelHandler> T get(Class<T> var1);\n\n    ChannelHandlerContext context(ChannelHandler var1);\n\n    ChannelHandlerContext context(String var1);\n\n    ChannelHandlerContext context(Class<? extends ChannelHandler> var1);\n\n    Channel channel();\n\n    List<String> names();\n\n    Map<String, ChannelHandler> toMap();\n\n    ChannelPipeline fireChannelRegistered();\n\n    ChannelPipeline fireChannelUnregistered();\n\n    ChannelPipeline fireChannelActive();\n\n    ChannelPipeline fireChannelInactive();\n\n    ChannelPipeline fireExceptionCaught(Throwable var1);\n\n    ChannelPipeline fireUserEventTriggered(Object var1);\n\n    ChannelPipeline fireChannelRead(Object var1);\n\n    ChannelPipeline fireChannelReadComplete();\n\n    ChannelPipeline fireChannelWritabilityChanged();\n\n    ChannelPipeline flush();\n}\n\n```\n\n\n> **需要注意的是，ChannelHandler都是有其所属的EventLoop进行逻辑处理，以及传递给下一个ChannelHandler，前面提到了，EventLoop是一个线程，所以，不要阻塞ChannelPipeline中的ChannelHandler，可以由API看出，ChannelPipeline的核心API就是ChannelHandler的添加，替换，删除等操作，且addHandler()接受一个EventExecutorGroup参数，EventExecutorGroup继承自juc的ScheduleExecutorService,本质上是一个线程次，所以，可将添加的ChannelHandler交给其处理，从而从EventLoop中释放出来。带fire前缀的API是将Channel传递给下一个ChannelHandler处理，并执行其生命周期。**\n\n\n### Netty编解码器 ###\n\n***编解码器即将入站出站数据进行编码转换成正确的格式。所以，解码器继承自ChannelInboundHandler，而编码器继承自ChannelOutboudHandler,很好理解，入站数据为字节类型，需要解码成程序需要的类型，编码器正好相反。下面是编解码器类图：***\n\n![image]()\n\n**介绍几个重要的编解码器**\n\n***基于分隔分协议***\n\n\n***基于长度协议***\n\n\n***写大型数据***\n\n***序列化***\n\n### Netty数据容器ByteBuf###\n\n>ByteBuf 提供了对NIO中ByteBuffer的封装，ByteBuf提供三种模式。  \n\n堆缓存，即数据存储在jvm堆内存中，相当于nio中的ByteBuffer.allocate(int c);\n```\nByteBuf heapBuf = Unpooled.buffer()\n```\n直接缓存，直接存储在本机内存，相当于nio中的ByteBuffer.allcateDirect(int c);\n```\nByteVuf directBuf = Unpooled.directBuffer();\n```\n复合缓存区。通常，我们自定义的应用层协议都是如下方式。\n![image]([object Object])\n\n\n#### ByteBuf一些API\n\n- copy(),复制为一个新的ByteBuf,不共享。\n- slice(),保持对当前ByteBuf的引用，共享。\n- 读写操作，get()于set()，从当前索引开始，不改变索引位置；read()于write()，从当前索引开始，改变索引位置\n\n#### ByteBufHolder\n\n- content(),返回当前ByteBuf,\n- copy()，深拷贝，复制为一个新的ByteBuf,不共享。\n- duplicate(),浅拷贝，保持当前ByteBuf的引用，共享。\n\n#### ByteBufAllocatior,Netty提供两种缓存分配方式，池化与非池化，类图如下\n![image]()\n\n\n#### 引用计数\n\n> Netty引用计数\n\n\n\n\n\n\n\n\n\n","tags":["Netty"]},{"title":"浅谈线程池——ThreadPoolExecutor源码浅析(二)","url":"/2018/07/28/threadpool-2/","content":"\n*这一节就是分析ThreadPoolExecutor中的几个核心函数，分析完这几个函数之后，对于构造函数中的参数也就知其所以然了。*\n\n#### 入口函数execute(Runnable command)\n\n```\n\npublic void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n\n        int c = ctl.get();\n        //正在运行的线程数量小于 corePoolSize\n        if (workerCountOf(c) < corePoolSize) {\n            if (addWorker(command, true))\n                return;\n            c = ctl.get();\n        }\n        //当前线程数大于corePoolSize，则将其加入queue\n        if (isRunning(c) && workQueue.offer(command)) {\n            int recheck = ctl.get();\n            if (! isRunning(recheck) && remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n                addWorker(null, false);\n        }\n        //如果假如queue失败了呢?注意这里addworker第二个参数为false，即当前线程数只要不大于maximumPoolSize，就可以放入workSet中\n        else if (!addWorker(command, false))\n            reject(command);\n    }\n\n\n```\n\n>其实注释已经解释过了，三个判断：首先当前工作线程数小于corePoolSize，调用addWorker(command, true)；否则，将任务放入队列；但是如果加入队列失败，即队列已满了，继续调用addWorker(command, false)。不难看出，要了解具体逻辑，addWorker是一个关键的函数啊，注意，第一次调用addWorker，第二个参数传的是true，而第二次传的是false。那么看看addWorker函数吧。\n\n#### 核心函数addWorker(Runnable firstTask,boolean core)\n\n```\n private boolean addWorker(Runnable firstTask, boolean core) {\n        retry:\n        //CAS自旋\n        for (;;) {\n            \n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            //线程关闭，并且队列中的任务执行完了，直接返回false\n            if (rs >= SHUTDOWN &&\n                ! (rs == SHUTDOWN &&\n                   firstTask == null &&\n                   ! workQueue.isEmpty()))\n                return false;\n            //CAS自旋\n            for (;;) {\n                int wc = workerCountOf(c);\n                //当前线程数大于等于大容量或者大于等于核心线程数，最大线程数(取决于core值，这里就和execute方法里传进来的值相关了。）直接返回false\n                if (wc >= CAPACITY ||\n                    wc >= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n                //以上条件都不满足，说明任务可以进入works。将线程数cas自增，推出自旋。\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n            //注意这里的worker，就是juc并发工具的基础，AQS了/\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n            if (t != null) {\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // Recheck while holding lock.\n                    // Back out on ThreadFactory failure or if\n                    // shut down before lock acquired.\n                    int rs = runStateOf(ctl.get());\n\n                    if (rs < SHUTDOWN ||\n                        (rs == SHUTDOWN && firstTask == null)) {\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                        //将work加入set。\n                        workers.add(w);\n                        int s = workers.size();\n                        if (s > largestPoolSize)\n                            largestPoolSize = s;\n                        workerAdded = true;\n                    }\n                } finally {\n                    mainLock.unlock();\n                }\n                if (workerAdded) {\n                    //启动线程，那么启动的这个线程work由做了什么事情呢？\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n            if (! workerStarted)\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n\n```\n\n>核心逻辑就是判断状态，然后根据传进来的第二个boolean值执行逻辑，也就是说如果core=true，判断当前工作线程数小于corePoolSize；如果core=false，判断当前工作线程数小于maxPoolSize；条件成立，执行Worker中的线程。那么什么时候执行队列中的线程呢？队列的用处又在哪呢？\n\n#### Worker内部类\n\n```\npublic void run() {\n    runWorker(this);\n}\n```\n\n>Worker是一个内部类，继承自AQS(AbstractQueuedSynchronizer)，什么是AQS呢？很多并发工具都是基于AQS实现的，比如ReentranLock,CountLatchDown,CycleBarrir等，这里暂不详细讨论，以后可以单独分析。这里主要看Worker线程的run方法执行了什么逻辑呢，其实只是简单调用了 runWorker(this)外部方法,那看看这个方法吧!\n\n#### \n\n```\nfinal void runWorker(Worker w) {\n        Thread wt = Thread.currentThread();\n        Runnable task = w.firstTask;\n        w.firstTask = null;\n        w.unlock(); // allow interrupts\n        boolean completedAbruptly = true;\n        try {\n            //如果当前task不为空，则直接执行task,否则执行getTak()，执行其返回的task。那么getTask()执行了什么逻辑呢？\n            while (task != null || (task = getTask()) != null) {\n                w.lock();\n                // If pool is stopping, ensure thread is interrupted;\n                // if not, ensure thread is not interrupted.  This\n                // requires a recheck in second case to deal with\n                // shutdownNow race while clearing interrupt\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &&\n                      runStateAtLeast(ctl.get(), STOP))) &&\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                    task = null;\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n            completedAbruptly = false;\n        } finally {\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n```\n\n>核心逻辑就是当前传进来的任务不为空直接执行，为空的话执行getTask函数返回的任务，那么task什么时候会为空呢？就是工作线程执行完毕，并且线程池状态小于STOP。方法中还有两个函数beforeExecute和afterExecute，这两个方法的body为空，我们在自定义线程池的时候可以重写这两个方法，作用也就不言而喻了，可以在任务执行前后执行类似计数器或者一些其他逻辑。getTask返回的任务又是啥呢？其实就是从队列中取出一个任务了。代码如下：\n\n```\nprivate Runnable getTask() {\n        boolean timedOut = false; // Did the last poll() time out?\n\n        for (;;) {\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // Check if queue empty only if necessary.\n            if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n                decrementWorkerCount();\n                return null;\n            }\n\n            int wc = workerCountOf(c);\n\n            // Are workers subject to culling?\n            boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n            if ((wc > maximumPoolSize || (timed && timedOut))\n                && (wc > 1 || workQueue.isEmpty())) {\n                if (compareAndDecrementWorkerCount(c))\n                    return null;\n                continue;\n            }\n\n            try {\n            //核心逻辑就是从队列中取出一个任务返回\n                Runnable r = timed ?\n                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                    workQueue.take();\n                if (r != null)\n                    return r;\n                timedOut = true;\n            } catch (InterruptedException retry) {\n                timedOut = false;\n            }\n        }\n    }\n\n```\n\n#### 整体流程\n\n*那么整个过程其实就已经很清晰了，首先工作线程数低于corePoolSize，线程立即得到执行，否则加入队列，但是队列中的任务不能立即得到执行，需要等待调度，如果队列满了，那么工作线程数低于maxPoolSize的话，任务也能立即得到执行，只有等任务执行完后，再去调度队列中的任务。*\n\n#### 总结\n\n*通过分析线程池的构造函数参数的意思及其所控制的核心逻辑已经很清晰，剩下的其实就是线程池对于关闭，拒绝策略等实现细节了。*\n","tags":["Java"]},{"title":"浅谈线程池——ThreadPoolExecutor源码浅析(一)","url":"/2018/07/15/threadpool-1/","content":"\n*在进行核心逻辑分析之前，先对线程池中的一些变量进行讲解，这很重要。因为线程调度无非就是对这些状态变量（临界区资源）进行判断，然后做出相应的调度策略。*\n\n#### 基础变量\n\n```\n    //比特位29\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n    //线程池最大容量2^29 -1,二进制表示为:[00011111111111111111111111111111]\n    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n```\n\n#### 状态变量\n\n```\n\n    // runState is stored in the high-order bits\n    //如源码注释中所说，状态变量由二进制高位比特控制\n    //RUNNING---111[29位补0]\n    private static final int RUNNING    = -1 << COUNT_BITS;\n    //SHUTDOWN --- 000[29位补0]\n    private static final int SHUTDOWN   =  0 << COUNT_BITS;\n    //STOP --- 001[29位补0]\n    private static final int STOP       =  1 << COUNT_BITS;\n    //TIDYING --- 010[29位补0]\n    private static final int TIDYING    =  2 << COUNT_BITS;\n    //TERMINATED --- 011[29位补0]\n    private static final int TERMINATED =  3 << COUNT_BITS;\n\n```\n\n> 线程池维护了五种状态，由二进制中的高三位控制，为什么是高三位呢？其实也很好理解了，如果是高二位控制，那么就只有[11]、[10]、[01]、[00]四种状态，所以向上取整的话就是高三位了。那么这这五种状态分别代表什么含义呢？  \n\n* RUNNING：接受新任务并且处理已经进入阻塞队列的任务\n* SHUTDOWN：不接受新任务，但是处理已经进入阻塞队列的任务\n* STOP： 不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务\n* TIDYING：所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数\n* TERMINATED：terminated钩子函数已经运行完成\n  \n#### 数量和状态控制\n\n```\n    //初始值为：111[29位补0] | 000[29位补1] = 0\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\n```\n\n> ctl是一个原子整形变量，所以是线程安全的。这个变量高三位控制着线程池状态，低29位控制着线程池内的工作线程数。\n\n``` \n    private static int runStateOf(int c)     { return c & ~CAPACITY; }\n    private static int workerCountOf(int c)  { return c & CAPACITY; }\n    private static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n> 第一个函数runStateOf是用来计算运行状态的。~CAPACITY即CAPACITY取反，二进制表示为111[0000...低29位全为0...0000],那么如果一个数字与之进行且操作低29位就可以不用考虑了，不管怎样全位0，只有高三位会改变，这高三位也就是状态控制位。workerCountOf函数和runStateOf正好互补了，高三位位0，不变化，低29位是线程数量控制位，且CAPACITY低29位全为1，也就是说这个函数返回的就是入参的值，但是入参的值小于或等于CAPACITY，所以，我认为workerCountOf函数的主要功能其实就是控制线程池内的工作线程数，或者说maxPoolSize不能大于CAPACITY吧！\n\n\n>ctlOf(int rs, int wc)函数就是控制函数了，其逻辑就是rs(runState)和wc(workCount)取或了，什么意思呢?先看一下原子变量ctl的初始值是怎么计算出来的ctlOf(RUNNING, 0)，其意思就是RUNNING状态的工作线程数为0，因为runState状态位低29位都是0，而workCount高3位的值都是0，两个值取或后的结果值的高三位值取rs的值，低29位的值取wc的值，所以这个函数的本质就是当前处于rs状态的线程有wc个。举个例子：\n\n\n**rs = RUNNING,二进制表示为111 [00000000000000000000000000000];  \nwc = 100，二进制表示为000[00000000000000000000001100100];  \nrs | wc 的值为 [111][00000000000000000000001100100],即高三位取rs，低29为取wc，其意思就是处于RUNNING状态的线程有100个。**\n\n```\n    private static boolean runStateLessThan(int c, int s) {\n        return c < s;\n    }\n\n    private static boolean runStateAtLeast(int c, int s) {\n        return c >= s;\n    }\n\n    private static boolean isRunning(int c) {\n        return c < SHUTDOWN;\n    }\n\n    /**\n     * Attempts to CAS-increment the workerCount field of ctl.\n     */\n    private boolean compareAndIncrementWorkerCount(int expect) {\n        return ctl.compareAndSet(expect, expect + 1);\n    }\n\n    /**\n     * Attempts to CAS-decrement the workerCount field of ctl.\n     */\n    private boolean compareAndDecrementWorkerCount(int expect) {\n        return ctl.compareAndSet(expect, expect - 1);\n    }\n\n    /**\n     * Decrements the workerCount field of ctl. This is called only on\n     * abrupt termination of a thread (see processWorkerExit). Other\n     * decrements are performed within getTask.\n     */\n    private void decrementWorkerCount() {\n        do {} while (! compareAndDecrementWorkerCount(ctl.get()));\n    }\n```\n\n>再上面的一些函数就是状态判断和原子变量ctl的赋值操作，看函数名和注释就顾名思义了，不做过多解释了！\n\n#### 总结\n\n*再jdk源码中，有很多地方都用一个二进制比特来控制程序的不同变量，我想理解其中的思想还是很重要的，所以单独拿出来记录，以后如果分析其他jdk源码的时候碰到这种运算就很好理解了!*","tags":["Java"]},{"title":"浅谈线程池——Java中的线程池","url":"/2018/07/02/threadpool-0/","content":"\n#### 什么是线程池？  \n\n\n\n> 一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。——**摘自维基百科**   \n\n\n**通俗的说：线程池就是通过特定的策略来管理线程的创建，销毁，调度等工作。当然关于线程数设置多少合适这个问题其实要根据任务类型来说，一般计算密集型任务，取CPU数即可，I/O密集型任务理论上可以设置大一点，这个可以以后具体讨论。**  \n\n#### 线程的占用资源\n\n\n> 现代操作系统中的线程模型：栈空间，寄存器，程序计数器，线程上下文状态等。\n> Java中的线程当然也是通过native方法调用的操作系统线程。\n\n#### 线程切换开销  \n\n\n> 保留上下文状态以及恢复现场：线程A切换到线程B，需要保留线程A的状态(寄存器数据，程序计数> 器等),以及恢复线程B的上下文状态执行线程B。具体参照[维基百科](https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BA%A4%E6%8F%9B)\n\n#### Java线程池\n\n>Java中的线程池：TreadPoolExecutor(corePoolSize, maxPoolSize,keepAliveTime, TimeUnit,queue);\n\n*构造函数中参数的含义网上介绍一大堆，当然这里也稍微提一下。*  \n\n\n* corePoolSize：核心线程数,核心线程会一直存活，当前工作线程数低于corePoolSize的话，进入线程池的任务立即得到执行。\n* queueCapacity：任务队列容量（阻塞队列），当工作线程数量到达核心线程时，新任务会放在队列中排队等待执行。\n* maxPoolSize：最大线程数，当工作线程数>=corePoolSize，任务队列已满，工作线程数又小于maxPoolSize时，进入线程池的任务立即得到执行。\n* keepAliveTime：线程空闲时间。\n* allowCoreThreadTimeout：允许核心线程超时。\n* rejectedExecutionHandler：线程数大于maxPoolSize时，新加入线程池的任务的拒绝策略。\n\n#### JDK中的常用线程池  \n\n\n* Executors.newCachedThreadPool();\n\n```\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n\n> 本质上就是一个容器为Integer.MAX_VALUE的线程池，理论上进入线程池的任务先加入阻塞队列等待线程池调度。当然，阻塞队列满了后的任务都能立即得到执行。\n\n* Executors.newFixedThreadPool(10);\n  \n```\n    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n    }\n```\n\n> 本质上就是一个容量为nThreads的定长的线程池了。\n\n* Executors.newSingleThreadExecutor();\n\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n> 只有一个任务能立即得到执行，其余的都进入队列等待调度，队列满了执行相应的拒绝策略。\n\n* Executors.newScheduledThreadPool(100);\n\n> 定时任务调度器和上面的线程池不同，它继承自ThreadPoolExecutor,有自己的处理逻辑，暂不讨论了。\n\n*那么线程池ThreadPoolExecutor究竟是如何管理和调度线程的呢？这些参数又在ThreadPoolExecutor的执行过程中怎么进行逻辑控制的呢？放在[源码解析篇]()说吧。*  \n\n","tags":["Java"]},{"title":"关于毕业","url":"/2018/06/19/毕业/","content":"<div align=\"center\"> 关于毕业</div>\n=============\n>“还是学生嘛？\"  \n>\"前几天还是\"  \n\n&#160; &#160; &#160; &#160;也算是正在的毕业了。惋惜也好，遗憾也好，学习也罢，情感也罢。学生时代的时间留在回味就好了。  \n&#160; &#160; &#160; &#160;以前在学习也是，现在步入社会也是。我总是喜欢花时间去思考，安静、独立、理性。往近了说，我需要一个短期可实现的目标；往远了说，我需要做些什么样的事情，我想成为一个什么样的人；我需要去不断的思考。这对我来说是值得的。  \n&#160; &#160; &#160; &#160;上学时就写了些博客，全部关于技术。后来没有去规定，整理，也就找不全了。现在还是得慢慢去写点文字，分享些技术，记录些琐事，倾诉些情感，养成一个习惯。\n\n\n","tags":["琐事"]}]