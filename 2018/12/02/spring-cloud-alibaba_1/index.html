<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="一个懒人， 做点记录。">
    <meta name="keyword" content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        Nacos源码分析之naming - undefined
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 一个懒人，心态很丧。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.png">
        </div>
        <div class="name">
            <i>很懒，很丧</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li>
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li>
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li>
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li>
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos源码分析之naming"><span class="toc-text">Nacos源码分析之naming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#项目初始化"><span class="toc-text">项目初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Master选举"><span class="toc-text">Master选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heartbeat心跳连接"><span class="toc-text">Heartbeat心跳连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#后续"><span class="toc-text">后续</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input">
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> 一个懒人，心态很丧。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        Nacos源码分析之naming
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2018-12-02 17:42:14</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#Java,Nacos,Spring-cluod-alibaba,微服务" title="Java,Nacos,Spring-cluod-alibaba,微服务">Java,Nacos,Spring-cluod-alibaba,微服务</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>

    </div>
    <div class="post-content ">
        <h1 id="Nacos源码分析之naming"><a href="#Nacos源码分析之naming" class="headerlink" title="Nacos源码分析之naming"></a>Nacos源码分析之naming</h1><p><strong>nacos的naming服务采用分布式一致性算法-raft，来实现包括集群leader选举，数据和事物同步等功能。所以这一节也主要是分析raft在nacos-naming中的代码实现，以及个人的见解。</strong></p>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><p>整个nacos都是采用spring-boot作为基础框架，naming服务也不例外。整个raft算法的核心类为RaftCore类，其启动类为RunningConfig。RunningConfig实现了Spring-boot的ApplicationListner<webserverinitializedevent>,即在整个web项目初始化后即执行RunningConfig，在启动函数onApplicationEvent中启动RaftCore的初始化方法init(),代码如下。</webserverinitializedevent></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RunningConfig implements ApplicationListener&lt;WebServerInitializedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private static int serverPort;</span><br><span class="line"></span><br><span class="line">    private static String contextPath;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">    //启动函数，执行了RaftCore.init()方法。</span><br><span class="line">    @SuppressFBWarnings(&quot;ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(WebServerInitializedEvent event) &#123;</span><br><span class="line"></span><br><span class="line">        Loggers.SRV_LOG.info(&quot;[SERVER-INIT] got port:&quot; + event.getWebServer().getPort());</span><br><span class="line">        Loggers.SRV_LOG.info(&quot;[SERVER-INIT] got path:&quot; + servletContext.getContextPath());</span><br><span class="line"></span><br><span class="line">        serverPort = event.getWebServer().getPort();</span><br><span class="line">        contextPath = servletContext.getContextPath();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            RaftCore.init();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;failed to initialize raft sub system&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getServerPort() &#123;</span><br><span class="line">        return serverPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String getContextPath() &#123;</span><br><span class="line">        return contextPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是算法的核心类RaftCore了。这个类主要做了初始化工作，以及启动了三个scheduler分别定时执行MasterElection(Master选举）选举线程，HeartBeat(心跳连接)线程和AddressServerUpdater(集群服务添加和删除)线程。其中还有一个单独的线程不断轮询去执行通知事件。为了更加方便的理解RaftCore,先看看几个pojo类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">RaftPeer --&gt; d1[&quot;String ip //当前节点ip&quot;]</span><br><span class="line">RaftPeer --&gt; d2[&quot;String voteFor //发送给谁的选票&quot;]</span><br><span class="line">RaftPeer --&gt; d3[&quot;AtomicLong term //当前选举轮次&quot;]</span><br><span class="line">RaftPeer --&gt; d4[&quot;long leaderDueMs //leader选举的timeout&quot;]</span><br><span class="line">RaftPeer --&gt; d5[&quot;long heatbeatDueMs //心跳连接的timeout&quot;]</span><br><span class="line">RaftPeer --&gt; d6[&quot;State state //当前选举轮次当前节点状态&quot;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">PeerSet--&gt; d1[&quot;RaftPeer leader //当前的leader节点是谁&quot;]</span><br><span class="line">PeerSet--&gt; d2[&quot;Map&lt;String,RaftrPeer&gt; peers //当前集群中的节点&quot;]</span><br><span class="line">PeerSet--&gt; d3[&quot;Set&lt;String&gt; sites //当前集群中的ip列表&quot;]</span><br></pre></td></tr></table></figure>
<p>了解了这两个pojo类之后，再看RaftCore的具体逻辑就不会那么吃力了。首先是初始化函数init()，这个函数主要做了以下几件事情。</p>
<ol>
<li>启动Notifier线程，轮询执行通知事件。</li>
<li>恢复磁盘中的持久化数据。</li>
<li>从配置文件中读取服务集群的ip列表，如果列表长度大于0，就将initialized设置为true。理所当然的，initialized的状态也控制着是否执行MasterElection，HeartBeat和AddressServerUpdater的具体逻辑，因为如果集群ip列表为空，所有的逻辑也就毫无意义了。</li>
<li>启动MasterElection，HeartBeat和AddressServerUpdater的定时scheduler。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static void init() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       Loggers.RAFT.info(&quot;initializing Raft sub-system&quot;);</span><br><span class="line">       </span><br><span class="line">       //执行Notifier线程</span><br><span class="line">       executor.submit(notifier);</span><br><span class="line"></span><br><span class="line">       //从本地配置文件中读取servers列表</span><br><span class="line">       peers.add(NamingProxy.getServers());</span><br><span class="line"></span><br><span class="line">       long start = System.currentTimeMillis();</span><br><span class="line">       </span><br><span class="line">       //读取磁盘中的持久化数据Datum以及MataData，零拷贝</span><br><span class="line">       RaftStore.load();</span><br><span class="line"></span><br><span class="line">       Loggers.RAFT.info(&quot;cache loaded, peer count: &quot; + peers.size()</span><br><span class="line">               + &quot;, datum count: &quot; + datums.size()</span><br><span class="line">               + &quot;, current term:&quot; + peers.getTerm());</span><br><span class="line">       //自旋直到Notifer中的队列为空</span><br><span class="line">       while (true) &#123;</span><br><span class="line">           if (notifier.tasks.size() &lt;= 0) &#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           Thread.sleep(1000L);</span><br><span class="line">           System.out.println(notifier.tasks.size());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Loggers.RAFT.info(&quot;finish to load data from disk,cost: &quot; + (System.currentTimeMillis() - start) + &quot; ms.&quot;);</span><br><span class="line">       //定时任务执行Master选举过程</span><br><span class="line">       GlobalExecutor.register(new MasterElection());</span><br><span class="line">       //定时任务发送心跳包</span><br><span class="line">       GlobalExecutor.register1(new HeartBeat());</span><br><span class="line">       //定时任务更新服务列表</span><br><span class="line">       GlobalExecutor.register(new AddressServerUpdater(), GlobalExecutor.ADDRESS_SERVER_UPDATE_INTVERAL_MS);</span><br><span class="line">        //如果从文件读取的集群ip列表大于0，即可将initialized=true时，master选举、心跳连接的定时任务才能执行。</span><br><span class="line">       if (peers.size() &gt; 0) &#123;</span><br><span class="line">           if (lock.tryLock(INIT_LOCK_TIME_SECONDS, TimeUnit.SECONDS)) &#123;</span><br><span class="line">               initialized = true;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           throw new Exception(&quot;peers is empty.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Loggers.RAFT.info(&quot;timer started: leader timeout ms: &quot; + GlobalExecutor.LEADER_TIMEOUT_MS</span><br><span class="line">               + &quot;; heart-beat timeout ms: &quot; + GlobalExecutor.HEARTBEAT_INTVERAL_MS);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h3><p>接下来是Master选举过程，在nacos中的Raft-Master选举实现与标准的Raft算法实现一致。整个过程分以下几个步骤。</p>
<ol>
<li>所有节点的初始化状态均为Fllower.</li>
<li>每个节点都有一个随即的timeout，timeout具体值见下面源码。先结束timeout的节点状态变更为CANDIDATE，并且可以开始向其他节点请求发起投票。</li>
<li>收到投票请求的节点状态变为Follower，并向发起投票的节点返回投票结果。</li>
<li>发起投票的节点统计返回的投票数，如果投票数大于集群节点的一半+1，则当前节点变更为Master。</li>
<li>整个Master节点选举结束。</li>
</ol>
<p>代码如下：</p>
<blockquote>
<p>Master线程run()方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               //获取自己的Peer状态,所有节点的初始状态全为FOLLOWER</span><br><span class="line">               RaftPeer local = peers.local();</span><br><span class="line">               //等待一个超时</span><br><span class="line">               local.leaderDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line">               if (local.leaderDueMs &gt; 0) &#123;</span><br><span class="line">                   return;</span><br><span class="line">               &#125;</span><br><span class="line">               //第一个完成超时等待的FOLLOWER重置选举超时和心跳超时，并开始执行</span><br><span class="line">               sendVote();</span><br><span class="line">               // reset timeout</span><br><span class="line">               local.resetLeaderDue();</span><br><span class="line">               local.resetHeartbeatDue();</span><br><span class="line">               //开始执行sendVote();</span><br><span class="line">               sendVote();</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               Loggers.RAFT.warn(&quot;RAFT&quot;, &quot;error while master election&quot;, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>开始向其他节点发起投票请求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public static void sendVote() &#123;</span><br><span class="line">          //还没初始化直接退出</span><br><span class="line">          if (!initialized) &#123;</span><br><span class="line">              // not ready yet</span><br><span class="line">              return;</span><br><span class="line">          &#125;</span><br><span class="line">          //获取当前节点状态</span><br><span class="line">          RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">          Loggers.RAFT.info(&quot;leader timeout, start voting,leader: &quot; + JSON.toJSONString(getLeader()) + &quot;, term: &quot; + local.term);</span><br><span class="line">          重置状态，leader=null，并且voteFors=null</span><br><span class="line">          peers.reset();</span><br><span class="line">          //选举轮次自增</span><br><span class="line">          local.term.incrementAndGet();</span><br><span class="line">          //设置ip，方便之后计算收到的选票数量</span><br><span class="line">          local.voteFor = local.ip;</span><br><span class="line">          //状态变更为CANDIDATE</span><br><span class="line">          local.state = RaftPeer.State.CANDIDATE;</span><br><span class="line">          //向其他节点发送请求，请求其他节点发送vote</span><br><span class="line">          Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(1);</span><br><span class="line">          params.put(&quot;vote&quot;, JSON.toJSONString(local));</span><br><span class="line">          for (final String server : peers.allServersWithoutMySelf()) &#123;</span><br><span class="line">              final String url = buildURL(server, API_VOTE);</span><br><span class="line">              try &#123;</span><br><span class="line">                  HttpClient.asyncHttpPost(url, null, params, new AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                      @Override</span><br><span class="line">                      public Integer onCompleted(Response response) throws Exception &#123;</span><br><span class="line">                          //异步接受来自其他节点的vote</span><br><span class="line">                          if (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                              Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;vote failed: &quot;</span><br><span class="line">                                      , response.getResponseBody() + &quot; url:&quot; + url);</span><br><span class="line"></span><br><span class="line">                              return 1;</span><br><span class="line">                          &#125;</span><br><span class="line"></span><br><span class="line">                          RaftPeer peer = JSON.parseObject(response.getResponseBody(), RaftPeer.class);</span><br><span class="line"></span><br><span class="line">                          Loggers.RAFT.info(&quot;received approve from peer: &quot; + JSON.toJSONString(peer));</span><br><span class="line">                          //决定是否成为Leader节点</span><br><span class="line">                          peers.decideLeader(peer);</span><br><span class="line"></span><br><span class="line">                          return 0;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125; catch (Exception e) &#123;</span><br><span class="line">                  Loggers.RAFT.warn(&quot;error while sending vote to server:&quot; + server);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>收到投票请求的节点处理逻辑，并返回投票<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//接受vote请求</span><br><span class="line">      public static RaftPeer receivedVote(RaftPeer remote) &#123;</span><br><span class="line">          //集群中不包含改远程节点，抛出异常</span><br><span class="line">          if (!peers.contains(remote)) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;can not find peer: &quot; + remote.ip);</span><br><span class="line">          &#125;</span><br><span class="line">          //未初始化，直接跑出异常</span><br><span class="line">          if (!initialized) &#123;</span><br><span class="line">              throw new IllegalStateException(&quot;not ready yet&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          //获取本地节点状态</span><br><span class="line">          RaftPeer local = peers.get(NetUtils.localServer());</span><br><span class="line">          //保证选票在同一轮中进行</span><br><span class="line">          if (remote.term.get() &lt;= local.term.get()) &#123;</span><br><span class="line">              String msg = &quot;received illegitimate vote&quot; +</span><br><span class="line">                      &quot;, voter-term:&quot; + remote.term + &quot;, votee-term:&quot; + local.term;</span><br><span class="line"></span><br><span class="line">              Loggers.RAFT.info(msg);</span><br><span class="line">              if (StringUtils.isEmpty(local.voteFor)) &#123;</span><br><span class="line">                  local.voteFor = local.ip;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              return local;</span><br><span class="line">          &#125;</span><br><span class="line">          //重新设置选举时间</span><br><span class="line">          local.resetLeaderDue();</span><br><span class="line">          //状态变更并返回给Leader</span><br><span class="line">          local.state = RaftPeer.State.FOLLOWER;</span><br><span class="line">          local.voteFor = remote.ip;</span><br><span class="line">          local.term.set(remote.term.get());</span><br><span class="line"></span><br><span class="line">          Loggers.RAFT.info(&quot;vote &quot; + remote.ip + &quot; as leader, term:&quot; + remote.term);</span><br><span class="line"></span><br><span class="line">          return local;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>投票结果统计，确定Master</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Candidate收到超过一半的选举votes，则Candidate状态变更为Leader;</span><br><span class="line">  public RaftPeer decideLeader(RaftPeer candidate) &#123;</span><br><span class="line">      peers.put(candidate.ip, candidate);</span><br><span class="line"></span><br><span class="line">      SortedBag ips = new TreeBag();</span><br><span class="line">      int maxApproveCount = 0;</span><br><span class="line">      String maxApprovePeer = null;</span><br><span class="line">      for (RaftPeer peer : peers.values()) &#123;</span><br><span class="line">          if (StringUtils.isEmpty(peer.voteFor)) &#123;</span><br><span class="line">              continue;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ips.add(peer.voteFor);</span><br><span class="line">          //选出说到选票最多的节点</span><br><span class="line">          if (ips.getCount(peer.voteFor) &gt; maxApproveCount) &#123;</span><br><span class="line">              maxApproveCount = ips.getCount(peer.voteFor);</span><br><span class="line">              maxApprovePeer = peer.voteFor;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      //当选票最多的节点选票数大于一半即可选举为leader</span><br><span class="line">      if (maxApproveCount &gt;= majorityCount()) &#123;</span><br><span class="line">          RaftPeer peer = peers.get(maxApprovePeer);</span><br><span class="line">          peer.state = RaftPeer.State.LEADER;</span><br><span class="line"></span><br><span class="line">          if (!Objects.equals(leader, peer)) &#123;</span><br><span class="line">              leader = peer;</span><br><span class="line">              Loggers.RAFT.info(leader.ip + &quot; has become the LEADER&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return leader;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>为方便理解整个流程，下面是整个Master选举的UML流程图</strong></p>
<p><img src="/images/master_electron_flow_chart.png" alt="master_electron_flow_chart"></p>
<h3 id="Heartbeat心跳连接"><a href="#Heartbeat心跳连接" class="headerlink" title="Heartbeat心跳连接"></a>Heartbeat心跳连接</h3><p><strong>Master选举完之后，需要通过心跳机制来维持与follower连接。连接过程也是通过一个timeout之后，Master向follower发送心跳请求，follower收到心态请求后向Master返回一个ack，费话不多说，直接上代码。</strong></p>
<blockquote>
<p>首先是HeartBeat线程的run()方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        //同样先获取本机状态，并维护一个心跳超时</span><br><span class="line">        RaftPeer local = peers.local();</span><br><span class="line">        local.heartbeatDueMs -= GlobalExecutor.TICK_PERIOD_MS;</span><br><span class="line">        if (local.heartbeatDueMs &gt; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        local.resetHeartbeatDue();</span><br><span class="line">        //发送心跳</span><br><span class="line">        sendBeat();</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        Loggers.RAFT.warn(&quot;RAFT&quot;, &quot;error while sending beat&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Master开始向follower发送心跳</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public static void sendBeat() throws IOException, InterruptedException &#123;</span><br><span class="line">            RaftPeer local = peers.local();</span><br><span class="line">            //判断当前节点状态为Leaer并且非单机模式，才需要向follower发送心跳连接</span><br><span class="line">            if (local.state != RaftPeer.State.LEADER &amp;&amp; !STANDALONE_MODE) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Loggers.RAFT.info(&quot;[RAFT] send beat with &quot; + datums.size() + &quot; keys.&quot;);</span><br><span class="line">            //重置选举超时</span><br><span class="line">            local.resetLeaderDue();</span><br><span class="line"></span><br><span class="line">            // 组装心跳数据</span><br><span class="line">            JSONObject packet = new JSONObject();</span><br><span class="line">            packet.put(&quot;peer&quot;, local);</span><br><span class="line"></span><br><span class="line">            JSONArray array = new JSONArray();</span><br><span class="line">            </span><br><span class="line">            if (Switch.isSendBeatOnly()) &#123;</span><br><span class="line">                Loggers.RAFT.info(&quot;[SEND-BEAT-ONLY] &quot; + String.valueOf(Switch.isSendBeatOnly()));</span><br><span class="line">            &#125;</span><br><span class="line">            //如果仅仅是心跳连接，则不需要组装数据</span><br><span class="line">            if (!Switch.isSendBeatOnly()) &#123;</span><br><span class="line">                for (Datum datum : datums.values()) &#123;</span><br><span class="line"></span><br><span class="line">                    JSONObject element = new JSONObject();</span><br><span class="line">                    String key;</span><br><span class="line"></span><br><span class="line">                    if (datum.key.startsWith(UtilsAndCommons.DOMAINS_DATA_ID)) &#123;</span><br><span class="line">                        key = (datum.key).split(UtilsAndCommons.DOMAINS_DATA_ID)[1];</span><br><span class="line">                        element.put(&quot;key&quot;, UtilsAndCommons.RAFT_DOM_PRE + key);</span><br><span class="line">                    &#125; else if (datum.key.startsWith(UtilsAndCommons.IPADDRESS_DATA_ID_PRE)) &#123;</span><br><span class="line">                       key = (datum.key).split(UtilsAndCommons.IPADDRESS_DATA_ID_PRE)[1];</span><br><span class="line">                        element.put(&quot;key&quot;, UtilsAndCommons.RAFT_IPLIST_PRE + key);</span><br><span class="line">                    &#125; else if (datum.key.startsWith(UtilsAndCommons.TAG_DOMAINS_DATA_ID)) &#123;</span><br><span class="line">                        key = (datum.key).split(UtilsAndCommons.TAG_DOMAINS_DATA_ID)[1];</span><br><span class="line">                        element.put(&quot;key&quot;, UtilsAndCommons.RAFT_TAG_DOM_PRE + key);</span><br><span class="line">                    &#125; else if (datum.key.startsWith(UtilsAndCommons.NODE_TAG_IP_PRE)) &#123;</span><br><span class="line">                        key = (datum.key).split(UtilsAndCommons.NODE_TAG_IP_PRE)[1];</span><br><span class="line">                        element.put(&quot;key&quot;, UtilsAndCommons.RAFT_TAG_IPLIST_PRE + key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    element.put(&quot;timestamp&quot;, datum.timestamp);</span><br><span class="line"></span><br><span class="line">                    array.add(element);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                Loggers.RAFT.info(&quot;[RAFT] send beat only.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            packet.put(&quot;datums&quot;, array);</span><br><span class="line">            // broadcast</span><br><span class="line">            Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;(1);</span><br><span class="line">            params.put(&quot;beat&quot;, JSON.toJSONString(packet));</span><br><span class="line"></span><br><span class="line">            String content = JSON.toJSONString(params);</span><br><span class="line"></span><br><span class="line">            ByteArrayOutputStream out = new ByteArrayOutputStream();</span><br><span class="line">            GZIPOutputStream gzip = new GZIPOutputStream(out);</span><br><span class="line">            gzip.write(content.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            gzip.close();</span><br><span class="line"></span><br><span class="line">            byte[] compressedBytes = out.toByteArray();</span><br><span class="line">            String compressedContent = new String(compressedBytes, &quot;UTF-8&quot;);</span><br><span class="line">            Loggers.RAFT.info(&quot;raw beat data size: &quot; + content.length() + &quot;, size of compressed data: &quot; + compressedContent.length());</span><br><span class="line">            //向除自己之外的follower节点发送心跳包</span><br><span class="line">            for (final String server : peers.allServersWithoutMySelf()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    final String url = buildURL(server, API_BEAT);</span><br><span class="line">                    Loggers.RAFT.info(&quot;send beat to server &quot; + server);</span><br><span class="line">                    HttpClient.asyncHttpPostLarge(url, null, compressedBytes, new AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public Integer onCompleted(Response response) throws Exception &#123;</span><br><span class="line">                            if (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                                Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;beat failed: &quot; + response.getResponseBody() + &quot;, peer: &quot; + server);</span><br><span class="line">                                return 1;</span><br><span class="line">                            &#125;</span><br><span class="line">                            //成功之后更新pees节点状态</span><br><span class="line">                            peers.update(JSON.parseObject(response.getResponseBody(), RaftPeer.class));</span><br><span class="line">                            Loggers.RAFT.info(&quot;receive beat response from: &quot; + url);</span><br><span class="line">                            return 0;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onThrowable(Throwable t) &#123;</span><br><span class="line">                            Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;error while sending heart-beat to peer: &quot; + server, t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;error while sending heart-beat to peer: &quot; + server, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>follower节点受到心态请求，返回ack</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">//接收来自leader的心跳请求</span><br><span class="line">       public static RaftPeer receivedBeat(JSONObject beat) throws Exception &#123;</span><br><span class="line">           final RaftPeer local = peers.local();</span><br><span class="line">           final RaftPeer remote = new RaftPeer();</span><br><span class="line">           remote.ip = beat.getJSONObject(&quot;peer&quot;).getString(&quot;ip&quot;);</span><br><span class="line">           remote.state = RaftPeer.State.valueOf(beat.getJSONObject(&quot;peer&quot;).getString(&quot;state&quot;));</span><br><span class="line">           remote.term.set(beat.getJSONObject(&quot;peer&quot;).getLongValue(&quot;term&quot;));</span><br><span class="line">           remote.heartbeatDueMs = beat.getJSONObject(&quot;peer&quot;).getLongValue(&quot;heartbeatDueMs&quot;);</span><br><span class="line">           remote.leaderDueMs = beat.getJSONObject(&quot;peer&quot;).getLongValue(&quot;leaderDueMs&quot;);</span><br><span class="line">           remote.voteFor = beat.getJSONObject(&quot;peer&quot;).getString(&quot;voteFor&quot;);</span><br><span class="line">           //发起方必须是leader</span><br><span class="line">           if (remote.state != RaftPeer.State.LEADER) &#123;</span><br><span class="line">               Loggers.RAFT.info(&quot;[RAFT] invalid state from master, state=&quot; + remote.state + &quot;, remote peer: &quot; + JSON.toJSONString(remote));</span><br><span class="line">               throw new IllegalArgumentException(&quot;invalid state from master, state=&quot; + remote.state);</span><br><span class="line">           &#125;</span><br><span class="line">           //选举轮次不能大于发起方选举轮次</span><br><span class="line">           if (local.term.get() &gt; remote.term.get()) &#123;</span><br><span class="line">               Loggers.RAFT.info(&quot;[RAFT] out of date beat, beat-from-term: &quot; + remote.term.get()</span><br><span class="line">                       + &quot;, beat-to-term: &quot; + local.term.get() + &quot;, remote peer: &quot; + JSON.toJSONString(remote) + &quot;, and leaderDueMs: &quot; + local.leaderDueMs);</span><br><span class="line">               throw new IllegalArgumentException(&quot;out of date beat, beat-from-term: &quot; + remote.term.get()</span><br><span class="line">                       + &quot;, beat-to-term: &quot; + local.term.get());</span><br><span class="line">           &#125;</span><br><span class="line">           //接受方如果不是follower，则需要将状态改为follower</span><br><span class="line">           if (local.state != RaftPeer.State.FOLLOWER) &#123;</span><br><span class="line"></span><br><span class="line">               Loggers.RAFT.info(&quot;[RAFT] make remote as leader &quot; + &quot;, remote peer: &quot; + JSON.toJSONString(remote));</span><br><span class="line">                 // mk follower</span><br><span class="line">               local.state = RaftPeer.State.FOLLOWER;</span><br><span class="line">               local.voteFor = remote.ip;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final JSONArray beatDatums = beat.getJSONArray(&quot;datums&quot;);</span><br><span class="line">           local.resetLeaderDue();</span><br><span class="line">           local.resetHeartbeatDue();</span><br><span class="line">           //设置发起方为leader</span><br><span class="line">           peers.makeLeader(remote);</span><br><span class="line"></span><br><span class="line">           Map&lt;String, Integer&gt; receivedKeysMap = new HashMap&lt;String, Integer&gt;(RaftCore.datums.size());</span><br><span class="line"></span><br><span class="line">           for (Map.Entry&lt;String, Datum&gt; entry : RaftCore.datums.entrySet()) &#123;</span><br><span class="line">               receivedKeysMap.put(entry.getKey(), 0);</span><br><span class="line">           &#125;</span><br><span class="line">       </span><br><span class="line">           // now check datums</span><br><span class="line">           List&lt;String&gt; batch = new ArrayList&lt;String&gt;();</span><br><span class="line">           //如果仅仅是心跳连接，直接返回local，不用组装数据</span><br><span class="line">           if (!Switch.isSendBeatOnly()) &#123;</span><br><span class="line">               int processedCount = 0;</span><br><span class="line">               Loggers.RAFT.info(&quot;[RAFT] received beat with &quot; + beatDatums.size() + &quot; keys, RaftCore.datums&apos; size is &quot;</span><br><span class="line">                       + RaftCore.datums.size() + &quot;,  remote server: &quot; + remote.ip + &quot;, term: &quot; + remote.term + &quot;,  local term: &quot; + local.term);</span><br><span class="line">               for (Object object : beatDatums) &#123;</span><br><span class="line">                   processedCount = processedCount + 1;</span><br><span class="line"></span><br><span class="line">                   JSONObject entry = (JSONObject) object;</span><br><span class="line">                   String key = entry.getString(&quot;key&quot;);</span><br><span class="line">                   final String datumKey;</span><br><span class="line"></span><br><span class="line">                   if (key.startsWith(UtilsAndCommons.RAFT_DOM_PRE)) &#123;</span><br><span class="line">                       int index = key.indexOf(UtilsAndCommons.RAFT_DOM_PRE);</span><br><span class="line">                       datumKey = UtilsAndCommons.DOMAINS_DATA_ID + key.substring(index + UtilsAndCommons.RAFT_DOM_PRE.length());</span><br><span class="line">                   &#125; else if (key.startsWith(UtilsAndCommons.RAFT_IPLIST_PRE)) &#123;</span><br><span class="line">                      int index = key.indexOf(UtilsAndCommons.RAFT_IPLIST_PRE);</span><br><span class="line">                       datumKey = UtilsAndCommons.IPADDRESS_DATA_ID_PRE + key.substring(index + UtilsAndCommons.RAFT_IPLIST_PRE.length());</span><br><span class="line">                   &#125; else if (key.startsWith(UtilsAndCommons.RAFT_TAG_DOM_PRE)) &#123;</span><br><span class="line">                       int index = key.indexOf(UtilsAndCommons.RAFT_TAG_DOM_PRE);</span><br><span class="line">                       datumKey = UtilsAndCommons.TAG_DOMAINS_DATA_ID + key.substring(index + UtilsAndCommons.RAFT_TAG_DOM_PRE.length());</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       int index = key.indexOf(UtilsAndCommons.RAFT_TAG_IPLIST_PRE);</span><br><span class="line">                       datumKey = UtilsAndCommons.NODE_TAG_IP_PRE + key.substring(index + UtilsAndCommons.RAFT_TAG_IPLIST_PRE.length());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   long timestamp = entry.getLong(&quot;timestamp&quot;);</span><br><span class="line"></span><br><span class="line">                   receivedKeysMap.put(datumKey, 1);</span><br><span class="line"></span><br><span class="line">                   try &#123;</span><br><span class="line">                       if (RaftCore.datums.containsKey(datumKey) &amp;&amp; RaftCore.datums.get(datumKey).timestamp.get() &gt;= timestamp &amp;&amp; processedCount &lt; beatDatums.size()) &#123;</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       if (!(RaftCore.datums.containsKey(datumKey) &amp;&amp; RaftCore.datums.get(datumKey).timestamp.get() &gt;= timestamp)) &#123;</span><br><span class="line">                           batch.add(datumKey);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       if (batch.size() &lt; 50 &amp;&amp; processedCount &lt; beatDatums.size()) &#123;</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       String keys = StringUtils.join(batch, &quot;,&quot;);</span><br><span class="line"></span><br><span class="line">                       if (batch.size() &lt;= 0) &#123;</span><br><span class="line">                           continue;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       Loggers.RAFT.info(&quot;get datums from leader: &quot; + getLeader().ip + &quot; , batch size is &quot; + batch.size() + &quot;, processedCount is &quot; + processedCount</span><br><span class="line">                               + &quot;, datums&apos; size is &quot; + beatDatums.size() + &quot;, RaftCore.datums&apos; size is &quot; + RaftCore.datums.size());</span><br><span class="line"></span><br><span class="line">                       // update datum entry</span><br><span class="line">                       String url = buildURL(remote.ip, API_GET) + &quot;?keys=&quot; + keys;</span><br><span class="line">                       HttpClient.asyncHttpGet(url, null, null, new AsyncCompletionHandler&lt;Integer&gt;() &#123;</span><br><span class="line">                           @Override</span><br><span class="line">                           public Integer onCompleted(Response response) throws Exception &#123;</span><br><span class="line">                               if (response.getStatusCode() != HttpURLConnection.HTTP_OK) &#123;</span><br><span class="line">                                   return 1;</span><br><span class="line">                               &#125;</span><br><span class="line"></span><br><span class="line">                               List&lt;Datum&gt; datumList = JSON.parseObject(response.getResponseBody(), new TypeReference&lt;List&lt;Datum&gt;&gt;() &#123;</span><br><span class="line">                               &#125;);</span><br><span class="line"></span><br><span class="line">                               for (Datum datum : datumList) &#123;</span><br><span class="line">                                   OPERATE_LOCK.lock();</span><br><span class="line">                                   try &#123;</span><br><span class="line"></span><br><span class="line">                                       Datum oldDatum = RaftCore.getDatum(datum.key);</span><br><span class="line"></span><br><span class="line">                                       if (oldDatum != null &amp;&amp; datum.timestamp.get() &lt;= oldDatum.timestamp.get()) &#123;</span><br><span class="line">                                           Loggers.RAFT.info(&quot;[VIPSRV-RAFT] timestamp is smaller than that of mine, key: &quot; +</span><br><span class="line">                                           datum.key</span><br><span class="line">                                                   + &quot;,remote: &quot; + datum.timestamp + &quot;, local: &quot; + oldDatum.timestamp);</span><br><span class="line">                                           continue;</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br><span class="line">                                       if (datum.key.startsWith(UtilsAndCommons.DOMAINS_DATA_ID)) &#123;</span><br><span class="line">                                           RaftStore.write(datum);</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br><span class="line">                                       RaftCore.datums.put(datum.key, datum);</span><br><span class="line">                                       local.resetLeaderDue();</span><br><span class="line"></span><br><span class="line">                                       if (datum.key.startsWith(UtilsAndCommons.DOMAINS_DATA_ID)) &#123;</span><br><span class="line">                                           if (local.term.get() + 100 &gt; remote.term.get()) &#123;</span><br><span class="line">                                               getLeader().term.set(remote.term.get());</span><br><span class="line">                                               local.term.set(getLeader().term.get());</span><br><span class="line">                                           &#125; else &#123;</span><br><span class="line">                                               local.term.addAndGet(100);</span><br><span class="line">                                           &#125;</span><br><span class="line"></span><br><span class="line">                                           RaftStore.updateTerm(local.term.get());</span><br><span class="line">                                       &#125;</span><br><span class="line"></span><br><span class="line">                                       Loggers.RAFT.info(&quot;data updated&quot; + &quot;, key=&quot; + datum.key</span><br><span class="line">                                               + &quot;, timestamp=&quot; + datum.timestamp + &quot;,from &quot; + JSON.toJSONString(remote) + &quot;, local term: &quot; + local.term);</span><br><span class="line"></span><br><span class="line">                                       notifier.addTask(datum,</span><br><span class="line">                                       Notifier.ApplyAction.CHANGE);</span><br><span class="line">                                   &#125; catch (Throwable e) &#123;</span><br><span class="line">                                       Loggers.RAFT.error(&quot;RAFT-BEAT&quot;, &quot;failed to sync datum from leader, key: &quot; + datum.key, e);</span><br><span class="line">                                   &#125; finally &#123;</span><br><span class="line">                                       OPERATE_LOCK.unlock();</span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               TimeUnit.MILLISECONDS.sleep(200);</span><br><span class="line">                               return 0;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line"></span><br><span class="line">                       batch.clear();</span><br><span class="line"></span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;failed to handle beat entry, key=&quot; + datumKey);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               List&lt;String&gt; deadKeys = new ArrayList&lt;String&gt;();</span><br><span class="line">               for (Map.Entry&lt;String, Integer&gt; entry : receivedKeysMap.entrySet()) &#123;</span><br><span class="line">                   if (entry.getValue() == 0) &#123;</span><br><span class="line">                       deadKeys.add(entry.getKey());</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               for (String deadKey : deadKeys) &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       deleteDatum(deadKey);</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       Loggers.RAFT.error(&quot;VIPSRV-RAFT&quot;, &quot;failed to remove entry, key=&quot; + deadKey, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           return local;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>###集群节点的添加与删除</p>
<p><strong>Nacos支持动态删除和添加集群节点，AddressServerUpdater的定时scheduler会去读取配置文件，然后动态更新集群节点状态，还是继续看代码把！</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//这个定时任务监听文件中配置的集群ip列表，进行集群服务的更新与删除</span><br><span class="line">    public static class AddressServerUpdater implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //从文件读取ip列表</span><br><span class="line">                List&lt;String&gt; servers = NamingProxy.getServers();</span><br><span class="line">                List&lt;RaftPeer&gt; peerList = new ArrayList&lt;RaftPeer&gt;(peers.allPeers());</span><br><span class="line">                List&lt;String&gt; oldServers = new ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">                if (CollectionUtils.isEmpty(servers)) &#123;</span><br><span class="line">                    Loggers.RAFT.warn(&quot;get empty server list from address server,ignore it.&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                for (RaftPeer peer : peerList) &#123;</span><br><span class="line">                    oldServers.add(peer.ip);</span><br><span class="line">                &#125;</span><br><span class="line">                //从文件读取的ip列表-集群中的ip列表 = 新服务</span><br><span class="line">                List&lt;String&gt; newServers = (List&lt;String&gt;) CollectionUtils.subtract(servers, oldServers);</span><br><span class="line">                if (!CollectionUtils.isEmpty(newServers)) &#123;</span><br><span class="line">                    //将新服务加入集群</span><br><span class="line">                    peers.add(newServers);</span><br><span class="line">                    Loggers.RAFT.info(&quot;[RAFT] server list is updated, new (&quot; + newServers.size() + &quot;) servers: &quot; + newServers);</span><br><span class="line">                &#125;</span><br><span class="line">                //集群中的ip列表 - 文件中读取的IP列表 = 需要从集群中删除的ip列表</span><br><span class="line">                List&lt;String&gt; deadServers = (List&lt;String&gt;) CollectionUtils.subtract(oldServers, servers);</span><br><span class="line">                if (!CollectionUtils.isEmpty(deadServers)) &#123;</span><br><span class="line">                    //从集群中移除需要删除的ip列表</span><br><span class="line">                    peers.remove(deadServers);</span><br><span class="line">                    Loggers.RAFT.info(&quot;[RAFT] server list is updated, dead (&quot; + deadServers.size() + &quot;) servers: &quot; + deadServers);</span><br><span class="line">                      &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                Loggers.RAFT.info(&quot;[RAFT] error while updating server list.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>nacos的raft是怎么保证集群中的master节点高可用的呢？在nacos中的实现方式是每次master选举完之后，重置timeout，然后在timeout结束后重新选举，这样，即使master选举完之后，不管master存活或者死亡，都会重新选举，来保证master节点的高可用，但是我觉得这种做法并不妥，因为如果master刚选举完就挂了，然后timeout还没有到，那这段时间内集群就不可用了，而Raft的标准实现是Leader维护timeout，如果timeout之间内没收到来自Master的心跳连接，则认为Master挂了，需要重新选举，因为心跳的timeout往往时间比Master选举的短很多，所以个人觉得会合适一些。</strong></p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p><strong> Raft算法进行Master选举完成之后，整个集群的所有集群状态同步，集群数据同步以及事务的执行都需要Raft的支持，在下一篇中会介绍这一部分的代码实现。 </strong></p>

        
        <div id="comment-container">
        </div>
    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

</html>
